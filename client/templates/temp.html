<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebSocket Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script>
</head>
<body>
  <h1>WebSocket Client</h1>
  <canvas id="frequencyChart" width="800" height="400"></canvas>
  <script>
    // Chart.js initialization
    const ctx = document.getElementById('frequencyChart').getContext('2d');
    const frequencyChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'Frequency vs Power (dB)',
          data: [],
          borderColor: 'rgba(75, 192, 192, 1)',
          backgroundColor: 'rgba(75, 192, 192, 0.2)',
          borderWidth: 1,
          pointRadius: 0,
        }]
      },
      options: {
        responsive: true,
        scales: {
          x: {
            type: 'linear',
            title: {
              display: true,
              text: 'Frequency (Hz)'
            }
          },
          y: {
            title: {
              display: true,
              text: 'Power (dB)'
            }
          }
        },
        plugins: {
          legend: {
            display: true,
            position: 'top'
          }
        }
      }
    });

    // Basic parameters
    const SAMPLE_RATE = 2.048e6;
    const N = 1024;  // Must match your server's block size if you want a clean FFT
    const FREQ_RESOLUTION = SAMPLE_RATE / N;

    // -------------------------------
    // (1) WebSocket to receive raw IQ data
    // -------------------------------
    const ws = new WebSocket("ws://localhost:8000/hi");

    ws.onopen = () => {
      console.log("WebSocket connected");
    };

    ws.onmessage = (event) => {
      event.data.arrayBuffer().then((buffer) => {
        // Convert raw binary data to int8
        const decodedData = new Int8Array(buffer);
        console.log("Decoded Data:", decodedData);

        // Convert to interleaved IQ samples: [I0, Q0, I1, Q1, ...]
        const iqArray = nj.zeros([decodedData.length / 2, 2]); // Nx2
        for (let i = 0, j = 0; i < decodedData.length; i += 2, j++) {
          iqArray.set(j, 0, decodedData[i]);     // I
          iqArray.set(j, 1, decodedData[i + 1]); // Q
        }

        // Optional: keep only the first N samples for the FFT
        const sliceLength = Math.min(N, iqArray.shape[0]);
        const truncatedIQ = iqArray.slice([0, sliceLength], [0, 2]);

        // Apply a window if desired (simple Hann window example)
        const windowedIQ = applyWindow(truncatedIQ, sliceLength);

        // Compute FFT (returns {real, imag})
        const fftResult = fft(windowedIQ, sliceLength);

        // Convert to power (dB)
        const { freqs, powerdB } = computePowerSpectrum(
          fftResult.real, 
          fftResult.imag, 
          SAMPLE_RATE
        );

        // Update Chart.js
        frequencyChart.data.labels = freqs;
        frequencyChart.data.datasets[0].data = powerdB;
        frequencyChart.update();
      });
    };

    ws.onclose = () => {
      console.log("WebSocket closed");
    };

    // -------------------------------
    // (2) Simple window function
    // -------------------------------
    function applyWindow(iqArray, length) {
      // Hann window
      for (let n = 0; n < length; n++) {
        const winVal = 0.5 * (1 - Math.cos((2 * Math.PI * n) / (length - 1)));
        iqArray.set(n, 0, iqArray.get(n, 0) * winVal);
        iqArray.set(n, 1, iqArray.get(n, 1) * winVal);
      }
      return iqArray;
    }

    // -------------------------------
    // (3) Minimal FFT implementation (Recursive Cooley-Tukey)
    //     For demonstration only. Use a tested library for production.
    // -------------------------------
    function fft(iqArray, length) {
      // Separate real/imag arrays from (I, Q)
      let real = new Float32Array(length);
      let imag = new Float32Array(length);
      for (let i = 0; i < length; i++) {
        real[i] = iqArray.get(i, 0);
        imag[i] = iqArray.get(i, 1);
      }

      fftRecursive(real, imag);

      return { real, imag };
    }

    // Recursive in-place Cooley-Tukey
    function fftRecursive(real, imag) {
      const n = real.length;
      if (n <= 1) return;

      // Divide array into even and odd
      const half = n >> 1;
      let evenReal = new Float32Array(half);
      let evenImag = new Float32Array(half);
      let oddReal  = new Float32Array(half);
      let oddImag  = new Float32Array(half);

      for (let i = 0; i < half; i++) {
        evenReal[i] = real[i * 2];
        evenImag[i] = imag[i * 2];
        oddReal[i]  = real[i * 2 + 1];
        oddImag[i]  = imag[i * 2 + 1];
      }

      fftRecursive(evenReal, evenImag);
      fftRecursive(oddReal, oddImag);

      // Combine
      for (let k = 0; k < half; k++) {
        const tReal =  Math.cos(-2 * Math.PI * k / n) * oddReal[k] 
                      - Math.sin(-2 * Math.PI * k / n) * oddImag[k];
        const tImag =  Math.sin(-2 * Math.PI * k / n) * oddReal[k] 
                      + Math.cos(-2 * Math.PI * k / n) * oddImag[k];
        real[k]         = evenReal[k] + tReal;
        imag[k]         = evenImag[k] + tImag;
        real[k + half]  = evenReal[k] - tReal;
        imag[k + half]  = evenImag[k] - tImag;
      }
    }

    // -------------------------------
    // (4) Compute frequency bins & power (dB)
    // -------------------------------
    function computePowerSpectrum(real, imag, sampleRate) {
      // Shift the FFT so 0 Hz is in the middle
      const n = real.length;
      const half = n >> 1;

      // Magnitude array
      const magnitude = new Array(n);
      for (let i = 0; i < n; i++) {
        magnitude[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) || 1e-9; // avoid log(0)
      }

      // Create a frequency axis from -sampleRate/2 to +sampleRate/2
      const freqs = new Array(n);
      const powerdB = new Array(n);
      for (let i = 0; i < n; i++) {
        // Index shifted to center
        const idxShifted = (i + half) % n; 
        // Convert magnitude to dB
        powerdB[i] = 20 * Math.log10(magnitude[idxShifted]);

        // Map index to frequency in Hz
        // Range: -sampleRate/2 ... sampleRate/2
        freqs[i] = ((i - half) * sampleRate) / n;
      }

      return { freqs, powerdB };
    }
  </script>
</body>
</html>
