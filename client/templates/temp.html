<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebSocket Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script>
  <script src="/static/jsfft.bundle.js"></script>
</head>
<script>
  const fft = new jsfft.ComplexArray(512);
  console.log(fft);
</script>
<body>
  <h1>WebSocket Client</h1>
  <canvas id="frequencyChart" width="800" height="400"></canvas>
  <script>
    // Basic parameters
    const SAMPLE_RATE = 2.048e6;
    const N = 1024;

    // Copy the global FFT constructor into a local variable
    // (Confirm 'window.FFT' is how fft.js is exposed by your build)
    const FFTConstructor = window.FFT; 

    // Chart initialization
    const ctx = document.getElementById('frequencyChart').getContext('2d');
    const frequencyChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'Frequency vs Power (dB)',
          data: [],
          borderColor: 'rgba(75, 192, 192, 1)',
          backgroundColor: 'rgba(75, 192, 192, 0.2)',
          borderWidth: 1,
          pointRadius: 0,
        }]
      },
      options: {
        responsive: false,
        scales: {
          x: {
            type: 'linear',
            title: {
              display: true,
              text: 'Frequency (Hz)',
              min: -SAMPLE_RATE / 2,
              max:  SAMPLE_RATE / 2
            }
          },
          y: {
            title: {
              display: true,
              text: 'Power (dB)'
            }
          }
        },
        plugins: {
          legend: { display: true, position: 'top' }
        }
      }
    });

    // WebSocket connection
    const ws = new WebSocket("ws://localhost:8000/hi");

    ws.onopen = () => {
      console.log("WebSocket connected");
    };

    ws.onmessage = (event) => {
      event.data.arrayBuffer().then((buffer) => {
        // Convert raw binary data (I/Q) to Int8
        const decodedData = new Int8Array(buffer);

        // Interleave I and Q into iqArray
        const iqArray = nj.zeros([decodedData.length / 2, 2]);
        for (let i = 0, j = 0; i < decodedData.length; i += 2, j++) {
          iqArray.set(j, 0, decodedData[i]);
          iqArray.set(j, 1, decodedData[i + 1]);
        }

        // Keep first N samples for FFT
        const sliceLength = Math.min(N, iqArray.shape[0]);
        const truncatedIQ = iqArray.slice([0, sliceLength], [0, 2]);

        // Apply Hann window
        applyWindow(truncatedIQ, sliceLength);

        // Set up fft.js arrays
        const f = new FFTConstructor(sliceLength);
        const inputComplex = f.createComplexArray();
        const outputComplex = f.createComplexArray();

        // Fill inputComplex with real=I, imag=Q
        for (let k = 0, cIndex = 0; k < sliceLength; k++) {
          inputComplex[cIndex++] = truncatedIQ.get(k, 0); // I
          inputComplex[cIndex++] = truncatedIQ.get(k, 1); // Q
        }

        // Perform FFT
        f.transform(outputComplex, inputComplex);

        // Convert to power (dB) and shift 0 Hz to center
        const { freqs, powerdB } = computePowerSpectrum(outputComplex, SAMPLE_RATE);

        // Update the chart
        frequencyChart.data.labels = freqs;
        frequencyChart.data.datasets[0].data = powerdB;
        frequencyChart.update();
      });
    };

    ws.onclose = () => {
      console.log("WebSocket closed");
    };

    // Hann window
    function applyWindow(iqArray, length) {
      for (let n = 0; n < length; n++) {
        const winVal = 0.5 * (1 - Math.cos((2 * Math.PI * n) / (length - 1)));
        iqArray.set(n, 0, iqArray.get(n, 0) * winVal);
        iqArray.set(n, 1, iqArray.get(n, 1) * winVal);
      }
    }

    // Convert complex FFT output to frequency vs power arrays
    function computePowerSpectrum(outputComplex, sampleRate) {
      const n = outputComplex.length >> 1;
      const half = n >> 1;

      const magnitude = new Float32Array(n);
      for (let i = 0, idx = 0; i < n; i++) {
        const re = outputComplex[idx++];
        const im = outputComplex[idx++];
        magnitude[i] = 20 * Math.log10(Math.sqrt(re * re + im * im) || 1e-9);
      }

      // Shift 0 Hz to center
      const freqs = [];
      const powerdB = [];
      for (let i = 0; i < n; i++) {
        const idxShifted = (i + half) % n;
        freqs[i]  = ((i - half) * sampleRate) / n;
        powerdB[i] = magnitude[idxShifted];
      }

      return { freqs, powerdB };
    }
  </script>
</body>
</html>
